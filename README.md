# Operating_systems

Learning course at 5th semester of BMSTU (2019)

## Lab 1
**Дизассемблирование INT 8h**

1. Получение начального адреса прерывания Int 8h. 
2. Используя sourser получить дизассемблерный код обработчика аппаратного прерывания от системного таймера Int 8h.
3. На основе полученного кода составить алгоритм работы обработчика Int 8h. 

**Функции обработчика прерываний от системного таймера**

1. Перечисление и исследование. 
2. Указать функции, которые выполняются по тику, главному тику и кванту. 
3. Отдельно для Windows, Unix/Linux. 
4. Исследование вопроса подсчета динамических приоритетов (только для приложений (пользовательских процессов))

*Источники литературы:*
1. Руссинович, Соломон "Внутренне устройство Microsoft Windows"
2. Вахалия "Unix изнутри"

## Lab 2
**Защищенный режим**

1. Организовать преход в защищенный и реальный режимы. 
2. Работа с клавиатурой и таймером - прерывания. 
3. Определить объем доступного адресного пространства. 

*Источники литературы:*
1. Рудаков, Финогенов "Прогарммируем на языке ассемблера"
2. Зубков "Ассемблер для Dos, Windows и Unix"

## Lab 3
**1 лабораторная по линуксу**

1. Напишите программу, в которой создается дочерний процесс и организуйте как в предке, так и в потомке бесконечные циклы. 
2. Запустите программу и посмотрите идентификаторы созданных процессов: предка и потомка;
3. Для получения процесса зомби (отобраны все ресурсы кроме последнего, строки в таблице процессов, необходимо чтобы предок мог получить статус завершения своего потомка) выполните следующие действия: 
  - удалите командой kill потомка и посмотрите с помощью команды ps его новый статус – Z;
  - удалите предка.
4. Для получения «осиротевшего» процесса запустите программу еще раз, но в этот раз удалите предка и посмотрите с помощью команды ps идентификатор предка у продолжающего выполняться потомка – идентификатор предка будет изменен на 1, так как процесс был «усыновлен» процессом с идентификатором 1 , процессом «открывшим» терминал.
5. Создать soft link(ссылка на файл, а именно это специальный файл, в котором только одна строка содержащая путь по которому нужно перейти при обращении к этой ссылке), hard link (еще одно имя файла). 
6. Изменить приоритет. renice -n 5 -p process

Можем только увеличить приоритет (без sudo - суперпользователя (доступны привелигированные команды и доступ к структуре ядра). Нельзя уменьшить, так как для этого требуется пересчет приоритетов. 

7. Именованный программный канал - специальный файл, в который можно писать информация и из которого можно читать. 
  -	создаем именованный программный канал командой mknod с именем pipe;
  -	направляем  текст в программный канал: echo [текст]  >  pipe
  -	меняем консоль;
  -	получаем через канал текст и используя команду tee, выводим на экран: tee < pipe  

Значения флагов:

- 0 - был fork и был exec (родительский процесс с флагом 0, так как была вызвана была вызвана команда запуска программы, она не принадлежит языку bash, поэтому создается процесс, котором выполняется сначала fork, потом exec)
- 1 - был fork но не было exec 
- 4 - суперюзер

Типы файлов:
- -- обычный
- d директория
- p именованный программный канал
- l soft link
- s socket
- c специальный файл символьного устройства (символьный файл)
- b специальный файл блочного устройства (блочный файл)

## Lab 4
**2 лабораторная по линуксу**

**1-я программа**
Написать программу, запускающую новый процесс системным вызовом fork(). В предке вывести собственный идентификатор (функция getpid()), идентификатор группы (функция getpgrp())  и идентификатор потомка. В процессе-потомке вывести собственный идентификатор, идентификатор предка (функция getppid()) и идентификатор группы. Убедиться, что при завершении процесса-предка потомок, который продолжает выполняться, получает идентификатор предка (PPID), равный 1 или идентификатор процесса-посредника.

Возникает процесс сирота. 
При завершении любого процесса система анализирует таблицы дескрипторов и если находит незавершившиеся потомки этого процесса выполняет следующие действия: PPID потомков присваивает 1 (это PID процесса, открывшего терминал) - усыновление.

**2-я программа**
Написать программу по схеме первого задания, но в процессе-предке выполнить системный вызов wait(). Убедиться, что в этом случае идентификатор процесса потомка на 1 больше идентификатора процесса-предка.

Cистемный вызов wait() блокирует родительский процесс до момента завершения дочернего. 

**3-я программа**
Написать программу, в которой процесс-потомок вызывает системный вызов exec(), а процесс-предок ждет завершения процесса-потомка.

Чаще всего нет смысла в выполнении двух одинаковых процессов и потомок сразу выполняет системный вызов exec(), параметрами которого является имя исполняемого файла и, если нужно, параметры, которые будут переданы этой программе. Говорят, что системный вызов exec() создает низкоуровневый процесс: создаются таблицы страниц для адресного пространства программы, указанной в exec(), но программа на выполнение не запускается, так как это не полноценный процесс, имеющий идентификатор и дескриптор. Системный вызов exec() создает таблицу страниц для адресного пространства программы, переданной ему в качестве параметра, а затем заменяет старый адрес новой таблицы страниц.

Возникает процесс-зомби – это процесс, у которого отобраны все ресурсы, кроме последнего – строки в таблице процессов.
Если потомок завершился(аварийно завершился exec), а предок завершился нормально, возникает зомби.

**4-я программа**
Написать программу, в которой предок и потомок обмениваются сообщением через программный канал.

Системный вызов pipe() - неименованный программный канал. Неименованные программные каналы могут использоваться для обмена сообщениями между процессами родственниками. В отличие от именованных программных каналов неименованные не имеют идентификатора, но имеют дескриптор. 

Программные каналы находятся в системной области памяти, т.к. адресные пространства процессов защищены и недоступны для других процессов.

**5-я программа**
В программу с программным каналом включить собственный обработчик сигнала. Использовать сигнал для изменения хода выполнения программы.

Обработчик сигнала задается с помощью системного вызова signal().
При нжатии на Ctrl+C менятся ход выполнения программы извне.

## Lab 5
**Производство-потребление**

## Lab 6
**Читатели-писатели для Linux/Windows**


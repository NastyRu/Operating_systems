; В данной части лабораторной работы выполняется
; переход в защищенный режим, вывод сообщения,
; переход в реальный и вывод сообщения.
; Инициализируются 4 сегмента (данных, кода, видеобуфера, стека (в данной части не используется))

; По материалам книги Рудаков, Финогенова "Программируем на языке ассемблера"


.386p ; Разрешение трансляции всех, в том
			; числе привилегированных команд МП 386
			; и 486

descr struc  ;структура для описания декскриптора сегмента
	limit 	dw 0	; Граница (биты 0..15)
	base_l 	dw 0	; База, биты 0..15
	base_m 	db 0	; База, биты 16..23
	attr_1 	db 0	; Байт атрибутов 1
	arrt_2 	db 0	; Граница(биты 16..19) и атрибуты 2
	base_h 	db 0	; База, биты 24..31
descr ends

data segment ; Начало сегмента данных
; Таблица глобальных дескрипторов GDT
	gdt_null descr <0,0,0,0,0,0> ; Нулевой дескриптор
	gdt_data descr <data_size-1,0,0,92h,0,0> ; Сегмент данных, селектор 8
	gdt_code descr <code_size-1,0,0,98h,0,0> ; Сегмент команд, селектор 16
	gdt_stack descr <255,0,0,92h,0,0> ; Сегмент стека, селектор 24
	gdt_screen descr <4095,8000h,0Bh,92h,0,0> ; Видеобуфер, селектор 32
	gdt_size=$-gdt_null ; Размер GDT
; Поля данных программы
	pdescr dq 0 ; Псевдодескриптор
	mes db "Real mode$" ; Сообщение для вывода в режиме реальном
	mes1 db "Protected mode$" ; Сообщение для вывода в режиме защищенном
	data_size=$-gdt_null ; Размер сегмента данных
data ends ; Конец сегмента данных

text segment 'code' use16 ; 16-разрядный режим
													; в первой части нам его достаточно
	assume CS:text, DS:data

main proc
		xor EAX,EAX ; Очистим EAX
		mov AX,data ; Загрузим в DS адрес сегмента данных
		mov DS,AX ; Адрес сегмента данных
; Вычислим 32-битовый линейный адрес сегмента данных и загрузим
; в дескриптор сегмента данных в GDT
		shl EAX,4 ; В EAX линейный базовый адрес
		mov EBP,EAX ; Сохраним его в EBP
		mov EBX,offset gdt_data ; В EBX адрес дескриптора
		mov [BX].base_l,AX ; Загрузим младшую часть базы
		rol EAX,16 ; Обмен старшей и младшей половин в EAX
		mov [BX].base_m,AL ; Загрузим среднюю чатсь базы
; Аналогично для сегмента комагд
		xor EAX,EAX
		mov AX,CS
		shl EAX,4
		mov EBX,offset gdt_code
		mov [BX].base_l,AX
		rol EAX,16
		mov [BX].base_m,AL
; Аналогично для сегмента стека
		xor EAX,EAX
		mov AX, SS
		shl EAX,4
		mov EBX,offset gdt_stack
		mov [BX].base_l,AX
		rol EAX,16
		mov [BX].base_m,AL
; Подготовим псевдодескриптор pdescr и загрузим регистр GDTR
		mov dword ptr pdescr+2,EBP ; База GDT, биты 0..31
		mov word ptr pdescr,gdt_size-1 ; Граница GDT
		lgdt pdescr ; Загрузим регистр GDTR
; Подготовимся к переходу в защтщенный режим
		cli ; Запрет аппаратных прерывания (маскируемых)
		mov AL,80h ;  Запрет NMI, немаскируемых прерываний
		out 70h,AL
; Переходим в защищенный режим
		mov EAX,CR0 ; Получим содержимое CR0
		or EAX,1 ; Установим бит PE
		mov CR0,EAX ; Запишем назад
; Теперь процессор работает в защищенном режиме
; Загружаем в CS:IP селектор:смещение точки continue
; и заодно очищаем очередь команд
		db 0EAh ; Код команды far jmp
		dw offset continue ; смещение
		dw 16 ; селектор сегменат команд

continue:
; Делаем адресуемыми данные
		mov AX,8 ; Селектор сегмента данных
		mov DS,AX
; Делаем адресуемым стек
		mov AX,24 ; Селектор сегмента стека
		mov SS,AX
; Делаем адресуемыми видеобуфер и выводим сообщение о прееходе
		mov AX,32 ; Селектор сегмента видеобуфера
		mov ES,AX
		mov BX,800 ; Начальное смещение на экране
		mov CX,15 ; Число выводимых символов
		mov SI,0 ; Итератор (смещение от начала)

screen:
		mov EAX,word ptr mes1[SI] ; Символ для вывода со смещением SI
		mov ES:[BX],EAX ; Вывод в видеобуфер
		add BX,2 ; Смещаемся в видеобуфере
		inc SI ; Следующий символ строки
		loop screen ; Цикл вывлода на экран
; Подготовим переход в реальный режи
; Сформируем и загрузим дескриптор для реального режима
; В нашем варинате не обязательно загружать FFFF, так как 16 битная система
		mov gdt_data.limit,0FFFFh ; Граница сегмента данных
		mov gdt_code.limit,0FFFFh ; Граница сегмента кода
		mov gdt_stack.limit,0FFFFh ; Граница сегмента стека
		mov gdt_screen.limit,0FFFFh ; Граница сегмента видеобуфера

		mov AX,8 ; Загрузим теневой регистр
		mov DS,AX ; сегмента данных
		mov AX,24 ; Загрузим теневой регистр
		mov SS,AX ; сегмента стека
		mov AX,32 ; Загрузим теневой регистр
		mov ES,AX ; сегмента видеобуфера
; Выполним дальний переход для того, чтобы заново
; загрузить слектор в регистр CS и модифицировать его теневой
		db 0EAh ; Командой дальнего перехода
		dw offset go ; загрузим теневой регситр
		dw 16 ; сегмента команд
; Переключим режим процессора
go:
		mov EAX,CR0 ; Получим содержимое CR0
		and EAX,0FFFFFFFEh ; Сбросим бит PE
		mov CR0,EAX ; Запишем назад
		db 0EAh ; Код команды far jmp
		dw offset return ; Смещение
		dw text ; Сегмент
; Теперь процессор снова работает а реальном режиме
; Восстановим операционную среду
return:
		mov AX,data ; Восстановим
		mov DS,AX ; адресуемость данных
		mov AX,stk ; Восстановим
		mov SS,AX ; адресуемость стека
; Разрешим аппартаные(маскируемые) и немаскируемые прерывания
		sti ; Разрешение аппаратных
		mov AL,0 ; Разрешение немаксируемых
		out 70h,AL
; Проверим выполнение функций DOS после возврата в реальный режим
		mov AH,09h ; Вывод сообщения
		mov EDX,offset mes
		int 21h
		mov AX,4C00h ; Завершение программы
		int 21h
		main endp

		code_size=$-main ; Размер сегмента кода(команд)
text ends

stk segment stack 'stack' ; Сегмент стека
		db 256 dup ('^')
stk ends

end main
